### 고객 관리 시스템  
1. 하고자 하는 일을 입력 받는다.  
- while문을 사용해서 입력 값이 제대로 들어왔으면 진행되고 그렇지 않으면 다시 하고자하는 일을 입력 받는다.
- input으로 아래의 값을 입력받고 그것을 변수 choice로 한다.
  > I - 고객 정보 입력  
  > C - 현재 고객 정보 조회  
  > P - 이전 고객 정보 조회  
  > N - 다음 고객 정보 조회  
  > U - 고객 정보 수정  
  > D - 고객 정보 삭제  
  > Q - 프로그램 종료  
- 제일 위에 입력한 값 설명
  > import re   ->  re 패키지 import
  > custlist=[]  -> 입력 받은 값을 customer 딕셔너리로 만들고, custlist에 리스트 형태로 집어 넣는다.
  > page=-1  -> 고객 정보를 조회할 때 페이지를 앞 뒤로 이동하면서 조회해야하기 때문에 미리 page 값을 -1로 지정한다.

2. 입력 (I)
- if문을 이용해서 input에서 I를 받으면 실행되는 것.  
  > customer 변수에 {'name':'','sex':'',"email":'',"birthyear":''} 딕셔너리를 만든다.
  1) input으로 이름을 받아서 키 값을 'name'으로 해서 값을 넣는다.
      > 형태는 string
  2) input으로 성별을 받아서 키 값을 'sex'로 해서 값을 넣는다. 형태 string.
      > 단, M/F로 표현하고 소문자면 대문자로 upper 함수로 바꿔준다.
  3) input으로 이메일은 받아서 키 값을 'email'로 해서 값을 넣는다. 
      > re패키지를 import 한다.
      > regex = re.compile('@')과 
      golbang = regex.search(customer['email']) customer 딕셔너리에 'email' 안에 @가 있는 지 검색.
      > if문으로 golbang이 none 값이 아니면 (= @가 있으면) break로 빠져나감.
      > 그렇지 않으면 '"@"를 포함한 정확한 이메일을 써주세요' 를 print
   4) input으로 출생년도를 받아서 키 값을 'birthyeaer'로 해서 값을 넣는다.
      > 입력 받은 값의 길이가 4이면 birthyear를 int 값으로 입력 받고 while문을 빠져나간다.
   5) 모든 값을 입력 받으면 customer 변수에 입력 받은 딕셔너리를 출력한다.
   6) customer 입력 받은 값을 custlist리스트에 추가한다.
   7) custlist를 출력한다.
   8) 입력이 완료되면 page +1 추가해 페이지를 하나 추가한다.

3. 현재 고객 정보 조회(C)
- 현재 페이지가 page+1 쪽이라고 출력하면서 custlist에 페이지 값을 넣어서 고객 정보 출력.
- 실제로 처음 입력받는 값은 page가 0인데, 사람에게 page는 1쪽부터 시작하기 때문에 이렇게 표현

4. 이전 고객 정보 조회(P)
- page 값이 0 이하이면 제일 첫 페이지기 때문에, 제일 첫 페이지라서 이동이 불가능하다는 안내를 하고 첫 페이지 출력.
- 그렇지 않으면 page 값을 -1을 하고 -1한 page+1 페이지고 그 값을 출력.

5. 다음 고객 정보 조회(N)
- page가 custlist의 길이(= 입력 받은 값들의 수 ) -1 보다 크면 데이터 중 마지막이라는 의미니까 마지막 페이지라고 출력하고 값을 출력한다.
- 아니면 page 값을 +1을 하고 현재 페이지가 page+1 쪽이라고 출력하고 해당 페이지를 출력한다.

6. 고객 정보 삭제(D)
- 삭제하려는 고객 정보의 이메일을 입력받고, choice1 변수에 넣는다.
- delok을 flag변수와 비슷한 역할로 만들었다. delok은 기본값이 0이고, 값을 삭제하면 1로 변해서 delok 값이 1이 되면 while문을 빠져나간다.
- for문 사용
  > range(0, len(custlist)) => custlist 리스트의 길이만큼 for문을 돌린다.
  > 입력받은 이메일 값이 있으면, {이름}고객님의 정보가 삭제되었습니다.라고 출력하고
  > 고객 정보를 지우고 custlist(지우고 나머지 고객 정보)를 출력한다.
  > 그리고 delok 값이 1이 되고 while문을 빠져나간다.
- for문이 끝나고 delok 값이 1이 되어서 빠져나간다.
- 검색 값이 없으면 delok이 0이기 때문에 값이 검색 되지 않고 '등록되지 않는 이메일'이라고 출력한다.

7. 고객 정보 수정(U)
- while문 사용. 수정하려는 고객 정보의 이메일을 입력받아서 choice1에 넣는다.
  > 이메일 값을 선택한 이유는 이메일 값이 unique 값이라고 생각했기 때문이다.
  > idx 기본값은 0이다. 이메일 값을 찾으면 idx를 반복한 i 값(=custlist의 index) 값으로 한다.
    그래서 이메일 값을 찾지 못하면 idx는 기본값 0이기 때문에 이것을 등록되지않은 이메일 값을 얻을 때 사용한다.
- custlist[i] 값에서 email 값이 입력 받은 choice1과 같으면 idx 값을 변경한다.
- 수정할 정보의 key 값을 직접 받아서 choice2에 넣고, 수정할 정보가 없으면 exit을 입력하게 한다.
  > choice2가 key 값인 name, sex, birthyear라면, custlist리스트에서 [인덱스(idx)] 값에
  input 함수를 통해 프롬프트에서 받은 수정한 값을 적용해서 수정한다.
  > exit을 입력받으면 break로 바로 탈출!
  > 아무것도 아니면, custlist 리스트 안에 없는 값이므로 '존재하지 않는 정보'라고 출력한다.
  > while문이기 때문에 맨 처음의 choice1로 돌아간다.

8. 프로그램 종료(Q)
 - Q를 입력받으면 바로 break로 간다. while문이 전체를 지배하고 있으니까 while문을 빠져나가고 종료.
